import 'dotenv/config';
import pkg from 'contentful-management';
const { createClient } = pkg;
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const client = createClient({
  accessToken: process.env.CONTENTFUL_MANAGEMENT_TOKEN,
});

const spaceId = '61iwodu7d9u0';

class ContentfulTableProcessor {
  constructor() {
    this.space = null;
    this.environment = null;
  }

  async init() {
    this.space = await client.getSpace(spaceId);
    this.environment = await this.space.getEnvironment('master');
  }

  async fetchTableComponent(tableId) {
    try {
      const tableConfig = await this.environment.getEntry(tableId);
      const contentType = tableConfig.sys.contentType.sys.id;

      if (contentType === 'tableOfContents') {
        return this.processTableOfContents(tableConfig);
      } else if (contentType === 'dataVisualizationTables') {
        return await this.processDataVisualizationTable(tableConfig);
      } else {
        console.warn(`Unknown table type: ${contentType}`);
        return null;
      }
    } catch (error) {
      console.error(`Error fetching table ${tableId}:`, error.message);
      return null;
    }
  }

  processTableOfContents(tableConfig) {
    const fields = tableConfig.fields;
    const title = fields.title?.['en-US'] || 'Table of Contents';
    const headerTags = fields.includedHeaderTags?.['en-US'] || ['H2'];
    const style = fields.style?.['en-US'] || 'List';
    const isSticky = fields.stickyOnScroll?.['en-US'] || false;

    return {
      type: 'tableOfContents',
      title,
      headerTags,
      style,
      isSticky,
      html: this.generateTOCHTML(title, headerTags, style, isSticky)
    };
  }

  async processDataVisualizationTable(tableConfig) {
    const fields = tableConfig.fields;
    const title = fields.title?.['en-US'] || 'Data Table';
    const sourceId = fields.source?.['en-US']?.sys?.id;

    if (!sourceId) {
      console.warn('No source ID found for data visualization table');
      return null;
    }

    try {
      const tableData = await this.environment.getEntry(sourceId);
      const rawData = tableData.fields.dataTable?.['en-US']?.tableData;

      if (!rawData || !Array.isArray(rawData)) {
        console.warn('No valid table data found');
        return null;
      }

      const filters = fields.filters?.['en-US'];
      const style = fields.style?.['en-US'] || 'Equal Width';
      const theme = fields.theme?.['en-US'] || 'Standard';
      const fullWidth = fields.fullWidth?.['en-US'] || false;

      return {
        type: 'dataVisualizationTable',
        title,
        style,
        theme,
        fullWidth,
        filters,
        rawData,
        html: this.generateDataTableHTML(title, rawData, filters, style, theme, fullWidth)
      };
    } catch (error) {
      console.error(`Error fetching table source ${sourceId}:`, error.message);
      return null;
    }
  }

  generateTOCHTML(title, headerTags, style, isSticky) {
    const stickyClass = isSticky ? ' toc-sticky' : '';
    const styleClass = style.toLowerCase().replace(/\s+/g, '-');
    
    return `
<!-- Table of Contents Component -->
<div class="contentful-toc${stickyClass} toc-style-${styleClass}">
  <h3 class="toc-title">${title}</h3>
  <div id="toc-${Date.now()}" class="toc-container" data-headers="${headerTags.join(',')}">
    <!-- TOC will be generated by JavaScript -->
  </div>
</div>

<script>
// Auto-generate TOC based on headers in content
(function() {
  const tocContainer = document.querySelector('.toc-container[data-headers]');
  if (!tocContainer) return;
  
  const headers = tocContainer.getAttribute('data-headers').split(',');
  const selector = headers.map(h => h.toLowerCase()).join(', ');
  const headings = document.querySelectorAll(selector);
  
  if (headings.length === 0) return;
  
  let tocHTML = '<ul class="toc-list">';
  headings.forEach((heading, index) => {
    const id = heading.id || \`heading-\${index}\`;
    if (!heading.id) heading.id = id;
    tocHTML += \`<li><a href="#\${id}">\${heading.textContent}</a></li>\`;
  });
  tocHTML += '</ul>';
  
  tocContainer.innerHTML = tocHTML;
})();
</script>

<style>
.contentful-toc {
  background: #f9f9f9;
  border: 1px solid #e0e0e0;
  border-radius: 5px;
  padding: 15px;
  margin: 20px 0;
}
.toc-sticky {
  position: sticky;
  top: 20px;
  z-index: 100;
}
.toc-title {
  margin-top: 0;
  color: #333;
}
.toc-list {
  list-style: none;
  padding: 0;
}
.toc-list li {
  margin: 5px 0;
}
.toc-list a {
  color: #0073aa;
  text-decoration: none;
}
.toc-list a:hover {
  text-decoration: underline;
}
</style>
`;
  }

  generateDataTableHTML(title, rawData, filters, style, theme, fullWidth) {
    if (!rawData || rawData.length === 0) return '';

    const [headerRow, ...dataRows] = rawData;
    const selectedColumns = filters?.selectedColumns || headerRow.map((col, i) => ({ id: i, name: col }));
    
    const widthClass = fullWidth ? 'table-full-width' : '';
    const styleClass = style.toLowerCase().replace(/\s+/g, '-');
    const themeClass = theme.toLowerCase().replace(/\s+/g, '-');

    let html = `
<!-- Data Visualization Table: ${title} -->
<div class="contentful-data-table ${widthClass} style-${styleClass} theme-${themeClass}">
  <h3 class="table-title">${title}</h3>
  <div class="table-responsive">
    <table class="data-table">
      <thead>
        <tr>
`;

    // Generate header
    selectedColumns.forEach(col => {
      const headerText = col.name !== '   ' ? col.name : '';
      html += `          <th>${headerText}</th>\n`;
    });

    html += `        </tr>
      </thead>
      <tbody>
`;

    // Generate data rows
    dataRows.forEach(row => {
      html += `        <tr>\n`;
      selectedColumns.forEach(col => {
        let cellData = '';
        if (typeof col.id === 'number' && row[col.id] !== undefined) {
          cellData = row[col.id];
        } else if (col.name && row[headerRow.indexOf(col.name)] !== undefined) {
          cellData = row[headerRow.indexOf(col.name)];
        }
        
        // Don't include the "key" column in output
        if (cellData !== 'all' && cellData !== 'key') {
          html += `          <td>${this.escapeHtml(cellData)}</td>\n`;
        } else {
          html += `          <td></td>\n`;
        }
      });
      html += `        </tr>\n`;
    });

    html += `      </tbody>
    </table>
  </div>
</div>

<style>
.contentful-data-table {
  margin: 20px 0;
}
.contentful-data-table.table-full-width {
  width: 100%;
}
.table-title {
  color: #333;
  margin-bottom: 10px;
}
.table-responsive {
  overflow-x: auto;
}
.data-table {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #ddd;
}
.data-table th,
.data-table td {
  border: 1px solid #ddd;
  padding: 12px 8px;
  text-align: left;
}
.data-table th {
  background-color: #f5f5f5;
  font-weight: bold;
  color: #333;
}
.data-table tbody tr:nth-child(even) {
  background-color: #f9f9f9;
}
.data-table tbody tr:hover {
  background-color: #f0f0f0;
}
.style-equal-width .data-table th,
.style-equal-width .data-table td {
  width: ${100 / selectedColumns.length}%;
}
</style>
`;

    return html;
  }

  escapeHtml(text) {
    if (typeof text !== 'string') return text;
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // Commented out for now - WordPress integration available
  // async updateWordPressPost(postSlug, tableHTML) {
  //   console.log(`üîÑ Would update WordPress post: ${postSlug}`);
  //   return true;
  // }

  async processAllTablesInPosts() {
    console.log('üöÄ Processing all tables in blog posts...\n');

    // Read the CSV export to get posts with tables
    const csvPath = path.join(__dirname, 'out', 'tables-detailed-export.csv');
    const csvContent = fs.readFileSync(csvPath, 'utf8');
    const lines = csvContent.split('\n').slice(1); // Skip header

    const processedTables = new Set();
    const results = [];

    for (const line of lines) {
      if (!line.trim()) continue;
      
      const [title, slug, postId, tableId, tableType] = line.split(',').map(field => 
        field.replace(/^"|"$/g, '').trim()
      );

      if (tableId === 'NO_TABLES') continue;
      if (processedTables.has(tableId)) continue;

      console.log(`üìä Processing table: ${tableId} for post: ${title.substring(0, 50)}...`);
      
      const tableData = await this.fetchTableComponent(tableId);
      
      if (tableData) {
        // Save table data as JSON
        const jsonPath = path.join(__dirname, 'out', 'tables', `${tableId}.json`);
        fs.mkdirSync(path.dirname(jsonPath), { recursive: true });
        fs.writeFileSync(jsonPath, JSON.stringify(tableData, null, 2));

        // Save table HTML
        const htmlPath = path.join(__dirname, 'out', 'tables', `${tableId}.html`);
        fs.writeFileSync(htmlPath, tableData.html);

        processedTables.add(tableId);
        results.push({
          tableId,
          postSlug: slug,
          postTitle: title,
          tableType: tableData.type,
          success: true
        });

        console.log(`   ‚úÖ Saved: ${jsonPath}`);
      } else {
        results.push({
          tableId,
          postSlug: slug,
          postTitle: title,
          tableType,
          success: false
        });
        console.log(`   ‚ùå Failed to process table`);
      }
    }

    // Save processing results
    const resultsPath = path.join(__dirname, 'out', 'table-processing-results.json');
    fs.writeFileSync(resultsPath, JSON.stringify(results, null, 2));

    console.log(`\nüìä Processing Summary:`);
    console.log(`Total tables processed: ${processedTables.size}`);
    console.log(`Successful: ${results.filter(r => r.success).length}`);
    console.log(`Failed: ${results.filter(r => !r.success).length}`);
    console.log(`\nFiles saved to: ${path.join(__dirname, 'out', 'tables')}`);
    
    return results;
  }
}

// Main execution
async function main() {
  const processor = new ContentfulTableProcessor();
  await processor.init();
  
  const results = await processor.processAllTablesInPosts();
  
  console.log('\nüéØ Next Steps:');
  console.log('1. Review generated HTML files in out/tables/');
  console.log('2. Use table JSON data to create WordPress shortcodes');
  console.log('3. Or inject HTML directly into WordPress posts');
  console.log('\nüìù WordPress Integration Options:');
  console.log('   Option A: Manual copy-paste HTML into posts');
  console.log('   Option B: Create WordPress shortcode [contentful-table id="tableId"]');
  console.log('   Option C: Auto-update posts via WordPress REST API');
}

main().catch(console.error);
